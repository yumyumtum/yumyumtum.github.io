<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Slope üéø</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
    font-family: 'Courier New', monospace;
    touch-action: none;
  }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
  }
  
  #hud {
    position: fixed;
    top: 20px;
    left: 20px;
    color: #0f0;
    font-size: 24px;
    font-weight: bold;
    text-shadow: 0 0 10px #0f0, 0 0 20px #0f0;
    z-index: 10;
    user-select: none;
  }
  
  #settingsButton {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 10px 20px;
    background: transparent;
    color: #0f0;
    border: 2px solid #0f0;
    font-size: 18px;
    cursor: pointer;
    font-family: 'Courier New', monospace;
    font-weight: bold;
    z-index: 10;
    transition: all 0.3s;
  }
  #settingsButton:hover {
    background: #0f0;
    color: #000;
    box-shadow: 0 0 20px #0f0;
  }
  
  .modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.95);
    padding: 40px;
    border: 3px solid #0f0;
    border-radius: 10px;
    text-align: center;
    display: none;
    z-index: 100;
    box-shadow: 0 0 30px #0f0;
    max-width: 500px;
    max-height: 90vh;
    overflow-y: auto;
  }
  
  .modal h1 {
    color: #0f0;
    font-size: 48px;
    margin: 0 0 30px 0;
    text-shadow: 0 0 20px #0f0;
  }
  
  .modal h2 {
    color: #0f0;
    font-size: 24px;
    margin: 25px 0 15px 0;
    text-shadow: 0 0 10px #0f0;
  }
  
  .modal p {
    color: #0f0;
    font-size: 18px;
    margin: 10px 0;
  }
  
  .modal button {
    margin: 10px 5px;
    padding: 15px 30px;
    font-size: 18px;
    background: transparent;
    color: #0f0;
    border: 2px solid #0f0;
    cursor: pointer;
    font-family: 'Courier New', monospace;
    font-weight: bold;
    transition: all 0.3s;
  }
  
  .modal button:hover, .modal button.active {
    background: #0f0;
    color: #000;
    box-shadow: 0 0 20px #0f0;
  }
  
  .slider-container {
    margin: 20px 0;
    padding: 20px;
    border: 2px solid rgba(0, 255, 0, 0.3);
    border-radius: 5px;
  }
  
  .slider-container label {
    color: #0f0;
    font-size: 18px;
    display: block;
    margin-bottom: 15px;
  }
  
  .slider-container input[type="range"] {
    width: 100%;
    height: 8px;
    background: rgba(0, 255, 0, 0.2);
    outline: none;
    -webkit-appearance: none;
  }
  
  .slider-container input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 25px;
    height: 25px;
    background: #0f0;
    cursor: pointer;
    border-radius: 50%;
    box-shadow: 0 0 10px #0f0;
  }
  
  .slider-container input[type="range"]::-moz-range-thumb {
    width: 25px;
    height: 25px;
    background: #0f0;
    cursor: pointer;
    border-radius: 50%;
    box-shadow: 0 0 10px #0f0;
  }
  
  .slider-value {
    color: #0f0;
    font-size: 24px;
    font-weight: bold;
    margin-top: 10px;
    text-shadow: 0 0 10px #0f0;
  }
  
  #gameOver {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    padding: 40px;
    border: 3px solid #0f0;
    border-radius: 10px;
    text-align: center;
    display: none;
    z-index: 20;
    box-shadow: 0 0 30px #0f0;
  }
  #gameOver h1 {
    color: #f00;
    font-size: 48px;
    margin: 0 0 20px 0;
    text-shadow: 0 0 20px #f00;
  }
  #gameOver p {
    color: #0f0;
    font-size: 24px;
    margin: 10px 0;
  }
  #gameOver button {
    margin-top: 20px;
    padding: 15px 40px;
    font-size: 20px;
    background: transparent;
    color: #0f0;
    border: 2px solid #0f0;
    cursor: pointer;
    font-family: 'Courier New', monospace;
    font-weight: bold;
    transition: all 0.3s;
  }
  #gameOver button:hover {
    background: #0f0;
    color: #000;
    box-shadow: 0 0 20px #0f0;
  }
  
  #startScreen {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    z-index: 100;
    color: #0f0;
  }
  #startScreen h1 {
    font-size: 64px;
    margin-bottom: 20px;
    text-shadow: 0 0 20px #0f0, 0 0 40px #0f0;
  }
  #startScreen p {
    font-size: 18px;
    margin: 10px 0;
    max-width: 400px;
    text-align: center;
    line-height: 1.6;
  }
  #startButton, #settingsButtonStart {
    margin-top: 15px;
    padding: 20px 50px;
    font-size: 24px;
    background: transparent;
    color: #0f0;
    border: 3px solid #0f0;
    cursor: pointer;
    font-family: 'Courier New', monospace;
    font-weight: bold;
    transition: all 0.3s;
  }
  #startButton:hover, #settingsButtonStart:hover {
    background: #0f0;
    color: #000;
    box-shadow: 0 0 30px #0f0;
  }
  
  /* Mobile controls */
  #mobileControls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    z-index: 30;
  }
  @media (max-width: 768px) {
    #mobileControls { display: flex; }
  }
  
  #joystick {
    width: 140px;
    height: 140px;
    background: rgba(0, 255, 0, 0.1);
    border: 3px solid rgba(0, 255, 0, 0.4);
    border-radius: 50%;
    position: relative;
  }
  #joystickKnob {
    position: absolute;
    width: 60px;
    height: 60px;
    background: rgba(0, 255, 0, 0.5);
    border: 2px solid #0f0;
    border-radius: 50%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    transition: all 0.1s;
    box-shadow: 0 0 15px #0f0;
  }
</style>
</head>
<body>

<div id="startScreen">
  <h1>üéø SLOPE</h1>
  <p><strong>Desktop:</strong> ‚Üê ‚Üí Arrow keys or A/D</p>
  <p><strong>Mobile:</strong> Use joystick</p>
  <p><br>Roll down the slope!</p>
  <p>Avoid red obstacles!</p>
  <button id="startButton">START GAME</button>
  <button id="settingsButtonStart">‚öôÔ∏è SETTINGS</button>
</div>

<div id="settingsModal" class="modal">
  <h1>‚öôÔ∏è SETTINGS</h1>
  
  <h2>üéØ DIFFICULTY PRESETS</h2>
  <p>Quick difficulty selection</p>
  <div>
    <button class="difficulty-btn" data-difficulty="easy">EASY (0.7x)</button>
    <button class="difficulty-btn" data-difficulty="normal">NORMAL (1.0x)</button>
    <button class="difficulty-btn" data-difficulty="hard">HARD (1.5x)</button>
    <button class="difficulty-btn" data-difficulty="insane">INSANE (2.5x)</button>
  </div>
  
  <h2>üéÆ GAME MODES</h2>
  <p>Different challenge styles</p>
  <div>
    <button class="mode-btn" data-mode="classic">CLASSIC</button>
    <button class="mode-btn" data-mode="zen">ZEN (No speed up)</button>
    <button class="mode-btn" data-mode="turbo">TURBO (Fast start)</button>
    <button class="mode-btn" data-mode="chaos">CHAOS (Random)</button>
  </div>
  
  <h2>üéöÔ∏è CUSTOM SPEED</h2>
  <p>Fine-tune your speed</p>
  <div class="slider-container">
    <label for="speedSlider">Base Speed Multiplier</label>
    <input type="range" id="speedSlider" min="0.5" max="3" step="0.1" value="1.0">
    <div class="slider-value"><span id="speedValue">1.0</span>x</div>
  </div>
  
  <button id="saveSettings" style="margin-top: 30px; padding: 20px 40px; font-size: 22px;">SAVE & CLOSE</button>
</div>

<button id="settingsButton">‚öôÔ∏è</button>

<div id="hud">
  Score: <span id="score">0</span><br>
  Speed: <span id="speed">1.0</span>x<br>
  <span id="modeDisplay" style="font-size: 16px;"></span>
</div>

<div id="gameOver">
  <h1>GAME OVER</h1>
  <p>Final Score: <span id="finalScore">0</span></p>
  <p>Distance: <span id="finalDistance">0</span>m</p>
  <p>Mode: <span id="finalMode"></span></p>
  <button id="restartButton">RESTART</button>
  <button id="menuButton">MAIN MENU</button>
</div>

<div id="mobileControls">
  <div id="joystick">
    <div id="joystickKnob"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;

// Settings
let gameSettings = {
  baseSpeed: 1.0,
  mode: 'classic',
  difficulty: 'normal'
};

// Load saved settings
try {
  const saved = localStorage.getItem('slopeSettings');
  if (saved) {
    gameSettings = { ...gameSettings, ...JSON.parse(saved) };
  }
} catch (e) {}

let gameStarted = false;
let gameOver = false;
let score = 0;
let distance = 0;
let speed = 1.0;

// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
scene.fog = new THREE.Fog(0x000000, 20, 100);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 8, 12);
camera.lookAt(0, 2, -10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(5, 10, 5);
scene.add(directionalLight);

// Ball
const ballGeometry = new THREE.SphereGeometry(0.5, 32, 32);
const ballMaterial = new THREE.MeshStandardMaterial({ 
  color: 0x00ff00,
  emissive: 0x00ff00,
  emissiveIntensity: 0.3,
  metalness: 0.5,
  roughness: 0.5
});
const ball = new THREE.Mesh(ballGeometry, ballMaterial);
ball.position.set(0, 1, 0);
ball.castShadow = true;
scene.add(ball);

let ballVelocityX = 0;
let ballVelocityY = 0;
const gravity = -0.03;
const moveSpeed = 0.08;

// Slope segments
const segments = [];
const segmentLength = 20;
const segmentWidth = 12;
let lastSegmentZ = 0;

function createSegment(z) {
  const group = new THREE.Group();
  
  const geometry = new THREE.PlaneGeometry(segmentWidth, segmentLength);
  const material = new THREE.MeshStandardMaterial({ 
    color: 0x222222,
    side: THREE.DoubleSide
  });
  const segment = new THREE.Mesh(geometry, material);
  segment.rotation.x = -Math.PI / 2.5;
  segment.position.set(0, 0, z - segmentLength / 2);
  group.add(segment);
  
  const wallGeometry = new THREE.BoxGeometry(0.3, 1.5, segmentLength);
  const wallMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x00ff00,
    emissive: 0x00ff00,
    emissiveIntensity: 0.2
  });
  const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
  leftWall.position.set(-segmentWidth / 2, 0.75, z - segmentLength / 2);
  group.add(leftWall);
  
  const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
  rightWall.position.set(segmentWidth / 2, 0.75, z - segmentLength / 2);
  group.add(rightWall);
  
  scene.add(group);
  segments.push(group);
  return group;
}

for (let i = 0; i < 10; i++) {
  createSegment(lastSegmentZ);
  lastSegmentZ -= segmentLength;
}

const obstacles = [];

function createObstacle(z) {
  const types = ['cube', 'wall', 'spike'];
  const type = types[Math.floor(Math.random() * types.length)];
  
  const slopeAngle = Math.PI / 2.5;
  const baseY = 1 + (z * Math.sin(slopeAngle - Math.PI/2)) * 0.08;
  
  let obstacle;
  
  if (type === 'cube') {
    const size = 1 + Math.random() * 0.5;
    const geometry = new THREE.BoxGeometry(size, size, size);
    const material = new THREE.MeshStandardMaterial({ 
      color: 0xff0000,
      emissive: 0xff0000,
      emissiveIntensity: 0.3
    });
    obstacle = new THREE.Mesh(geometry, material);
    obstacle.position.set(
      (Math.random() - 0.5) * (segmentWidth - 2),
      baseY + size / 2,
      z
    );
  } else if (type === 'wall') {
    const geometry = new THREE.BoxGeometry(3, 2, 0.5);
    const material = new THREE.MeshStandardMaterial({ 
      color: 0xff0000,
      emissive: 0xff0000,
      emissiveIntensity: 0.3
    });
    obstacle = new THREE.Mesh(geometry, material);
    obstacle.position.set(
      (Math.random() - 0.5) * (segmentWidth - 3),
      baseY + 1,
      z
    );
  } else {
    const geometry = new THREE.ConeGeometry(0.5, 1.5, 4);
    const material = new THREE.MeshStandardMaterial({ 
      color: 0xff0000,
      emissive: 0xff0000,
      emissiveIntensity: 0.4
    });
    obstacle = new THREE.Mesh(geometry, material);
    obstacle.position.set(
      (Math.random() - 0.5) * (segmentWidth - 1),
      baseY + 0.75,
      z
    );
  }
  
  obstacle.castShadow = true;
  scene.add(obstacle);
  obstacles.push(obstacle);
}

let obstacleSpawnZ = -20;
function spawnObstacles() {
  if (obstacleSpawnZ > ball.position.z - 100) {
    const spacing = 5 - Math.min(speed * 0.3, 2);
    createObstacle(obstacleSpawnZ);
    obstacleSpawnZ -= spacing;
  }
}

const keys = {};
window.addEventListener('keydown', (e) => keys[e.key] = true);
window.addEventListener('keyup', (e) => keys[e.key] = false);

let joystickActive = false;
let joystickDelta = 0;

if (isMobile) {
  const joystick = document.getElementById('joystick');
  const joystickKnob = document.getElementById('joystickKnob');

  joystick.addEventListener('touchstart', (e) => {
    e.preventDefault();
    joystickActive = true;
    updateJoystick(e.touches[0]);
  });

  joystick.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (joystickActive) updateJoystick(e.touches[0]);
  });

  joystick.addEventListener('touchend', (e) => {
    e.preventDefault();
    joystickActive = false;
    joystickDelta = 0;
    joystickKnob.style.transform = "translate(-50%, -50%)";
  });

  function updateJoystick(touch) {
    const rect = joystick.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    
    let dx = touch.clientX - centerX;
    const maxDistance = 40;
    
    if (Math.abs(dx) > maxDistance) {
      dx = Math.sign(dx) * maxDistance;
    }
    
    joystickDelta = dx / maxDistance;
    joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), -50%)`;
  }
}

function checkCollision() {
  const ballBox = new THREE.Box3().setFromObject(ball);
  
  for (let obstacle of obstacles) {
    const obstacleBox = new THREE.Box3().setFromObject(obstacle);
    if (ballBox.intersectsBox(obstacleBox)) {
      return true;
    }
  }
  
  if (Math.abs(ball.position.x) > segmentWidth / 2 || ball.position.y < -5) {
    return true;
  }
  
  return false;
}

function update() {
  if (!gameStarted || gameOver) return;
  
  ballVelocityY += gravity;
  
  if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
    ballVelocityX -= moveSpeed;
  }
  if (keys['ArrowRight'] || keys['d'] || keys['D']) {
    ballVelocityX += moveSpeed;
  }
  
  if (isMobile && joystickActive) {
    ballVelocityX += joystickDelta * moveSpeed * 0.8;
  }
  
  ballVelocityX *= 0.85;
  ball.position.x += ballVelocityX;
  ball.position.y += ballVelocityY;
  
  // Apply mode-specific speed calculations
  if (gameSettings.mode === 'zen') {
    speed = gameSettings.baseSpeed;
  } else if (gameSettings.mode === 'turbo') {
    speed = gameSettings.baseSpeed * (2.0 + distance * 0.0002);
  } else if (gameSettings.mode === 'chaos') {
    speed = gameSettings.baseSpeed * (1.0 + Math.sin(distance * 0.01) * 0.5 + distance * 0.0001);
  } else {
    speed = gameSettings.baseSpeed * (1.0 + distance * 0.0001);
  }
  
  const forwardSpeed = 0.15 * speed;
  ball.position.z -= forwardSpeed;
  distance += forwardSpeed;
  
  const slopeAngle = Math.PI / 2.5;
  const slopeY = 1 + (ball.position.z * Math.sin(slopeAngle - Math.PI/2)) * 0.08;
  
  if (ball.position.y < slopeY) {
    ball.position.y = slopeY;
    ballVelocityY = 0;
  }
  
  ball.rotation.x -= 0.15 * speed;
  ball.rotation.z += ballVelocityX * 0.1;
  
  camera.position.z = ball.position.z + 12;
  camera.position.y = ball.position.y + 8;
  camera.position.x = ball.position.x * 0.3;
  camera.lookAt(ball.position.x, ball.position.y, ball.position.z - 10);
  
  for (let i = segments.length - 1; i >= 0; i--) {
    if (segments[i].position.z > ball.position.z + 30) {
      scene.remove(segments[i]);
      segments.splice(i, 1);
    }
  }
  
  if (segments.length < 10) {
    createSegment(lastSegmentZ);
    lastSegmentZ -= segmentLength;
  }
  
  spawnObstacles();
  
  for (let i = obstacles.length - 1; i >= 0; i--) {
    if (obstacles[i].position.z > ball.position.z + 20) {
      scene.remove(obstacles[i]);
      obstacles.splice(i, 1);
    }
  }
  
  score = Math.floor(distance);
  document.getElementById('score').textContent = score;
  document.getElementById('speed').textContent = speed.toFixed(1);
  
  if (checkCollision()) {
    endGame();
  }
}

function endGame() {
  gameOver = true;
  document.getElementById('finalScore').textContent = score;
  document.getElementById('finalDistance').textContent = Math.floor(distance);
  document.getElementById('finalMode').textContent = gameSettings.mode.toUpperCase();
  document.getElementById('gameOver').style.display = 'block';
}

function restartGame() {
  ball.position.set(0, 1, 0);
  ballVelocityX = 0;
  ballVelocityY = 0;
  
  obstacles.forEach(obs => scene.remove(obs));
  obstacles.length = 0;
  obstacleSpawnZ = -20;
  
  segments.forEach(seg => scene.remove(seg));
  segments.length = 0;
  lastSegmentZ = 0;
  for (let i = 0; i < 10; i++) {
    createSegment(lastSegmentZ);
    lastSegmentZ -= segmentLength;
  }
  
  score = 0;
  distance = 0;
  speed = gameSettings.baseSpeed;
  gameOver = false;
  gameStarted = true;
  
  updateModeDisplay();
  document.getElementById('gameOver').style.display = 'none';
  camera.position.set(0, 8, 12);
}

function updateModeDisplay() {
  const modeNames = {
    'classic': 'Classic',
    'zen': 'Zen Mode',
    'turbo': 'Turbo Mode',
    'chaos': 'Chaos Mode'
  };
  document.getElementById('modeDisplay').textContent = `Mode: ${modeNames[gameSettings.mode]}`;
}

// Settings UI
const settingsModal = document.getElementById('settingsModal');
const speedSlider = document.getElementById('speedSlider');
const speedValue = document.getElementById('speedValue');

speedSlider.value = gameSettings.baseSpeed;
speedValue.textContent = gameSettings.baseSpeed.toFixed(1);

speedSlider.addEventListener('input', (e) => {
  const value = parseFloat(e.target.value);
  speedValue.textContent = value.toFixed(1);
  gameSettings.baseSpeed = value;
});

document.querySelectorAll('.difficulty-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    
    const difficulty = btn.dataset.difficulty;
    gameSettings.difficulty = difficulty;
    
    const speeds = { easy: 0.7, normal: 1.0, hard: 1.5, insane: 2.5 };
    gameSettings.baseSpeed = speeds[difficulty];
    speedSlider.value = gameSettings.baseSpeed;
    speedValue.textContent = gameSettings.baseSpeed.toFixed(1);
  });
  
  if (btn.dataset.difficulty === gameSettings.difficulty) {
    btn.classList.add('active');
  }
});

document.querySelectorAll('.mode-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    gameSettings.mode = btn.dataset.mode;
  });
  
  if (btn.dataset.mode === gameSettings.mode) {
    btn.classList.add('active');
  }
});

document.getElementById('saveSettings').addEventListener('click', () => {
  try {
    localStorage.setItem('slopeSettings', JSON.stringify(gameSettings));
  } catch (e) {}
  settingsModal.style.display = 'none';
});

document.getElementById('settingsButton').addEventListener('click', () => {
  settingsModal.style.display = 'block';
});

document.getElementById('settingsButtonStart').addEventListener('click', () => {
  settingsModal.style.display = 'block';
});

document.getElementById('startButton').addEventListener('click', () => {
  document.getElementById('startScreen').style.display = 'none';
  gameStarted = true;
  updateModeDisplay();
});

document.getElementById('restartButton').addEventListener('click', restartGame);

document.getElementById('menuButton').addEventListener('click', () => {
  document.getElementById('gameOver').style.display = 'none';
  document.getElementById('startScreen').style.display = 'flex';
  gameOver = false;
  gameStarted = false;
  
  ball.position.set(0, 1, 0);
  ballVelocityX = 0;
  ballVelocityY = 0;
  obstacles.forEach(obs => scene.remove(obs));
  obstacles.length = 0;
  obstacleSpawnZ = -20;
  segments.forEach(seg => scene.remove(seg));
  segments.length = 0;
  lastSegmentZ = 0;
  for (let i = 0; i < 10; i++) {
    createSegment(lastSegmentZ);
    lastSegmentZ -= segmentLength;
  }
  score = 0;
  distance = 0;
  speed = gameSettings.baseSpeed;
  camera.position.set(0, 8, 12);
});

function animate() {
  requestAnimationFrame(animate);
  update();
  renderer.render(scene, camera);
}

animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>